<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Open Mineral - Copper Supply Chain Journey</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            position: relative;
            touch-action: manipulation;
            height: 100vh;
            width: 100vw;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            -webkit-overflow-scrolling: touch;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #header {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 16px;
            border-radius: 8px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(184, 115, 51, 0.2);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
            max-width: calc(100vw - 16px);
            will-change: transform;
        }
        
        #logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 4px;
        }
        
        #logo-symbol {
            font-size: 16px;
            margin-right: 6px;
            background: linear-gradient(45deg, #b87333, #cd853f);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: #b87333;
        }
        
        #logo-text {
            font-size: 14px;
            font-weight: 700;
            background: linear-gradient(45deg, #4A90E2, #357abd);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: #4A90E2;
            letter-spacing: 1px;
        }
        
        #tagline {
            font-size: 9px;
            color: #666;
            font-weight: 500;
        }
        
        #navigation {
            position: fixed;
            top: 55px;
            left: 8px;
            right: 8px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 8px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(184, 115, 51, 0.2);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
            will-change: transform;
            max-height: calc(100vh - 140px);
            overflow: hidden;
        }
        
        .nav-title {
            color: #b87333;
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(184, 115, 51, 0.2);
            padding-bottom: 3px;
            text-align: center;
        }
        
        .nav-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        .nav-button {
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.1), rgba(74, 144, 226, 0.05));
            border: 1px solid rgba(74, 144, 226, 0.2);
            color: #333;
            padding: 8px 6px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 9px;
            text-align: center;
            font-weight: 600;
            white-space: nowrap;
            min-height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            -webkit-tap-highlight-color: transparent;
            font-family: inherit;
            will-change: transform;
        }
        
        .nav-button:hover {
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.2), rgba(74, 144, 226, 0.1));
        }
        
        .nav-button:active {
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.3), rgba(74, 144, 226, 0.2));
            transform: scale(0.98);
        }
        
        .nav-button.active {
            background: linear-gradient(135deg, rgba(184, 115, 51, 0.2), rgba(184, 115, 51, 0.1));
            border-color: rgba(184, 115, 51, 0.4);
            color: #b87333;
            font-weight: 700;
        }
        
        #stage-info {
            position: fixed;
            bottom: 8px;
            left: 8px;
            right: 8px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(184, 115, 51, 0.2);
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
            will-change: transform;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }
        
        #stage-title {
            color: #b87333;
            font-size: 12px;
            margin-bottom: 6px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #stage-description {
            line-height: 1.3;
            font-size: 10px;
            color: #555;
            margin-bottom: 8px;
        }
        
        .process-details {
            font-size: 9px;
            color: #666;
            font-style: italic;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(184, 115, 51, 0.2);
        }
        
        .metrics {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid rgba(184, 115, 51, 0.2);
            gap: 8px;
        }
        
        .metric {
            text-align: center;
            flex: 1;
        }
        
        .metric-value {
            font-size: 11px;
            font-weight: bold;
            color: #4A90E2;
        }
        
        .metric-label {
            font-size: 8px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 2px;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 14px;
            z-index: 1000;
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .loading-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid rgba(184, 115, 51, 0.3);
            border-top: 3px solid #b87333;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 15px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .transition-indicator {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 90;
            background: rgba(184, 115, 51, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            will-change: opacity;
        }
        
        .transition-indicator.show {
            opacity: 1;
        }
        
        /* Mobile specific adjustments */
        @media (max-width: 480px) {
            #header {
                top: 5px;
                padding: 6px 12px;
            }
            
            #navigation {
                top: 45px;
                padding: 6px;
            }
            
            .nav-title {
                font-size: 9px;
                margin-bottom: 4px;
                padding-bottom: 2px;
            }
            
            .nav-button {
                padding: 6px 4px;
                font-size: 8px;
                min-height: 38px;
            }
            
            #stage-info {
                padding: 8px;
                bottom: 5px;
            }
            
            #stage-title {
                font-size: 11px;
                margin-bottom: 4px;
            }
            
            #stage-description {
                font-size: 9px;
                margin-bottom: 6px;
            }
            
            .process-details {
                font-size: 8px;
                margin-top: 4px;
                padding-top: 4px;
            }
            
            .metrics {
                margin-top: 6px;
                padding-top: 4px;
                gap: 6px;
            }
            
            .metric-value {
                font-size: 10px;
            }
            
            .metric-label {
                font-size: 7px;
            }
            
            .transition-indicator {
                bottom: 110px;
                font-size: 10px;
                padding: 6px 12px;
            }
        }
        
        /* Desktop adjustments */
        @media (min-width: 769px) {
            #navigation {
                left: 20px;
                right: auto;
                width: 200px;
                top: 80px;
                padding: 12px;
            }
            
            .nav-title {
                font-size: 11px;
                margin-bottom: 8px;
                padding-bottom: 4px;
            }
            
            .nav-buttons {
                grid-template-columns: 1fr;
                gap: 6px;
            }
            
            .nav-button {
                padding: 10px 12px;
                font-size: 11px;
                min-height: auto;
            }
            
            #stage-info {
                bottom: 20px;
                right: 20px;
                left: auto;
                width: 320px;
                padding: 15px;
            }
            
            #header {
                padding: 12px 24px;
            }
            
            #logo-symbol {
                font-size: 18px;
            }
            
            #logo-text {
                font-size: 16px;
            }
            
            #tagline {
                font-size: 10px;
            }
            
            .transition-indicator {
                bottom: 120px;
            }
        }
        
        /* Error state styling */
        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            color: #d32f2f;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            z-index: 1001;
        }
        
        .error-button {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            font-family: inherit;
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loading-spinner"></div>
        <div>Loading Copper Supply Chain Experience...</div>
    </div>
    
    <div id="container">
        <div id="header">
            <div id="logo-container">
                <div id="logo-symbol">‚¨¢</div>
                <div id="logo-text">OPEN MINERAL</div>
            </div>
            <div id="tagline">Copper Supply Chain ‚Ä¢ From Mine to Final Product</div>
        </div>
        
        <div id="navigation">
            <div class="nav-title">Supply Chain Journey</div>
            <div class="nav-buttons">
                <button class="nav-button active" onclick="goToStage(0)" type="button" aria-label="View Ore Extraction stage">‚õèÔ∏è Ore Extraction</button>
                <button class="nav-button" onclick="goToStage(1)" type="button" aria-label="View Open Mineral platform stage">üî∂ Open Mineral</button>
                <button class="nav-button" onclick="goToStage(2)" type="button" aria-label="View Smelting stage">üî• Smelting</button>
                <button class="nav-button" onclick="goToStage(3)" type="button" aria-label="View Final Products stage">‚ú® Final Products</button>
            </div>
        </div>
        
        <div id="stage-info">
            <h3 id="stage-title">Open-Pit Mining Operations</h3>
            <p id="stage-description">Large-scale mining operations using drilling rigs, excavators, and conveyor systems to extract and process copper ore from geological deposits.</p>
            <div class="process-details" id="process-details">
                Drilling rigs create blast holes, explosives fragment rock, excavators load ore onto conveyor belts for processing and concentration.
            </div>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value">5-10%</div>
                    <div class="metric-label">Cu Content</div>
                </div>
                <div class="metric">
                    <div class="metric-value">24/7</div>
                    <div class="metric-label">Operations</div>
                </div>
                <div class="metric">
                    <div class="metric-value">1000+</div>
                    <div class="metric-label">Tons/Day</div>
                </div>
            </div>
        </div>
        
        <div id="transition-indicator" class="transition-indicator">
            Transitioning to next stage...
        </div>
    </div>

    <script>
        'use strict';
        
        // Global variables
        let scene, camera, renderer, currentStage = 0;
        let stages = [];
        let isTransitioning = false;
        let animationObjects = [];
        let miningEquipment = [];
        let tradingElements = [];
        let smeltingElements = [];
        let finalProducts = [];
        let animationId = null;
        let isWebGLSupported = true;
        let resizeTimeout = null;
        
        // Helper functions
        function isMobile() {
            return window.innerWidth <= 768;
        }
        
        function getScaleFactor() {
            return 1.0;
        }
        
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!context) return false;
                
                // Check for required extensions
                const requiredExtensions = ['OES_element_index_uint'];
                for (const ext of requiredExtensions) {
                    if (!context.getExtension(ext)) {
                        console.warn(`WebGL extension ${ext} not supported`);
                    }
                }
                
                return true;
            } catch (e) {
                console.error('WebGL support check failed:', e);
                return false;
            }
        }
        
        function showError(message) {
            const loadingEl = document.getElementById('loading');
            if (loadingEl) {
                loadingEl.innerHTML = `
                    <div class="error-message">
                        ${message}
                        <br>
                        <button class="error-button" onclick="location.reload()" type="button">Retry</button>
                    </div>
                `;
            }
        }
        
        // Stage data
        const stageData = Object.freeze([
            {
                title: "Open-Pit Mining Operations",
                description: "Large-scale mining operations using drilling rigs, excavators, and conveyor systems to extract and process copper ore from geological deposits.",
                process: "Drilling rigs create blast holes, explosives fragment rock, excavators load ore onto conveyor belts for processing and concentration.",
                metrics: [
                    { value: "5-10%", label: "Cu Content" },
                    { value: "24/7", label: "Operations" },
                    { value: "1000+", label: "Tons/Day" }
                ]
            },
            {
                title: "Open Mineral Digital Platform",
                description: "AI-powered trading platform with real-time pricing, blockchain transparency, and direct miner-to-smelter connections eliminating intermediaries.",
                process: "Advanced algorithms analyze commodity data, automated trading systems execute transactions, blockchain ensures transparent pricing.",
                metrics: [
                    { value: "14+", label: "Countries" },
                    { value: "$2B+", label: "Volume" },
                    { value: "AI", label: "Powered" }
                ]
            },
            {
                title: "Smelting & Refining Facilities",
                description: "Industrial smelting operations with high-temperature furnaces, electrolytic refining, and quality control systems producing 99.99% pure copper.",
                process: "Concentrates fed into blast furnaces at 1200¬∞C, molten copper refined through electrolysis, continuous monitoring ensures purity standards.",
                metrics: [
                    { value: "99.99%", label: "Purity" },
                    { value: "1200¬∞C", label: "Process Temp" },
                    { value: "24/7", label: "Production" }
                ]
            },
            {
                title: "Copper Final Products",
                description: "Manufacturing of copper pipes, electrical wiring, architectural sheets, and industrial components for construction and technology industries.",
                process: "Pure copper formed into pipes, drawn into wire, rolled into sheets, and fabricated into specialized components for various applications.",
                metrics: [
                    { value: "100+", label: "Years Life" },
                    { value: "99.9%", label: "Recyclable" },
                    { value: "Global", label: "Distribution" }
                ]
            }
        ]);
        
        function init() {
            try {
                // Check WebGL support first
                if (!checkWebGLSupport()) {
                    isWebGLSupported = false;
                    showError('WebGL is not supported in your browser. Please update your browser or enable WebGL support.');
                    return;
                }
                
                // Scene setup
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0xf8f9fa, 50, 200);
                
                // Camera setup with proper aspect ratio
                const fov = isMobile() ? 80 : 70;
                camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 15, 35);
                camera.lookAt(0, 0, 0);
                
                // Renderer setup with comprehensive error handling
                const rendererOptions = {
                    antialias: !isMobile(),
                    alpha: true,
                    powerPreference: "high-performance",
                    stencil: false,
                    depth: true,
                    preserveDrawingBuffer: false,
                    failIfMajorPerformanceCaveat: false
                };
                
                try {
                    renderer = new THREE.WebGLRenderer(rendererOptions);
                } catch (e) {
                    console.error('WebGL renderer creation failed:', e);
                    showError('Failed to initialize 3D graphics. Please check your graphics drivers and try again.');
                    return;
                }
                
                // Configure renderer
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
                renderer.setClearColor(0xf8f9fa, 1);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Use modern color space management
                if (renderer.outputColorSpace !== undefined) {
                    renderer.outputColorSpace = THREE.SRGBColorSpace;
                } else {
                    // Fallback for older Three.js versions
                    renderer.outputEncoding = THREE.sRGBEncoding;
                }
                
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                
                // Add renderer to DOM with error handling
                const container = document.getElementById('container');
                if (!container) {
                    throw new Error('Container element not found');
                }
                container.appendChild(renderer.domElement);
                
                // Setup scene components
                setupLighting();
                createBackground();
                createStages();
                
                // Initialize first stage
                goToStage(0);
                
                // Hide loading screen
                const loadingEl = document.getElementById('loading');
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                
                // Start animation and setup controls
                animate();
                setupControls();
                
            } catch (error) {
                console.error('Initialization error:', error);
                showError(`Error loading visualization: ${error.message}. Please refresh the page.`);
            }
        }
        
        function setupLighting() {
            try {
                // Ambient light for overall illumination
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                // Main directional light with shadows
                const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
                mainLight.position.set(20, 30, 20);
                mainLight.castShadow = true;
                
                // Optimize shadow settings based on device
                const shadowMapSize = isMobile() ? 512 : 1024;
                mainLight.shadow.mapSize.width = shadowMapSize;
                mainLight.shadow.mapSize.height = shadowMapSize;
                mainLight.shadow.camera.near = 0.1;
                mainLight.shadow.camera.far = 100;
                mainLight.shadow.camera.left = -50;
                mainLight.shadow.camera.right = 50;
                mainLight.shadow.camera.top = 50;
                mainLight.shadow.camera.bottom = -50;
                mainLight.shadow.bias = -0.0001;
                
                scene.add(mainLight);
                
                // Fill light to reduce harsh shadows
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
                fillLight.position.set(-20, 20, -20);
                scene.add(fillLight);
                
            } catch (error) {
                console.error('Lighting setup error:', error);
            }
        }
        
        function createBackground() {
            try {
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xe9ecef,
                    transparent: true,
                    opacity: 0.8
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -2;
                ground.receiveShadow = true;
                scene.add(ground);
            } catch (error) {
                console.error('Background creation error:', error);
            }
        }
        
        function createStages() {
            try {
                const stageSpacing = isMobile() ? 35 : 45;
                
                for (let i = 0; i < 4; i++) {
                    const stageGroup = new THREE.Group();
                    const xPos = (i - 1.5) * stageSpacing;
                    stageGroup.position.set(xPos, 0, 0);
                    
                    createStagePlatform(stageGroup, i);
                    createStageContent(stageGroup, i);
                    
                    if (i < 3) {
                        createConveyor(stageGroup, stageSpacing);
                    }
                    
                    stages.push(stageGroup);
                    scene.add(stageGroup);
                }
            } catch (error) {
                console.error('Stage creation error:', error);
            }
        }
        
        function createStagePlatform(group, stageIndex) {
            try {
                const platformGeometry = new THREE.CylinderGeometry(12, 12, 1, 32);
                const platformMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9
                });
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.y = -0.5;
                platform.receiveShadow = true;
                platform.castShadow = true;
                group.add(platform);
                
                // Platform accent with proper color setup
                const accentGeometry = new THREE.TorusGeometry(12, 0.3, 8, 32);
                const accentColor = stageIndex === 1 ? 0x4A90E2 : 0xb87333;
                const accentMaterial = new THREE.MeshPhongMaterial({ 
                    color: accentColor,
                    emissive: new THREE.Color(accentColor),
                    emissiveIntensity: 0.2
                });
                const accent = new THREE.Mesh(accentGeometry, accentMaterial);
                accent.position.y = 0;
                accent.rotation.x = Math.PI / 2;
                group.add(accent);
            } catch (error) {
                console.error('Platform creation error:', error);
            }
        }
        
        function createStageContent(group, stageIndex) {
            try {
                switch(stageIndex) {
                    case 0:
                        createMiningStage(group);
                        break;
                    case 1:
                        createTradingStage(group);
                        break;
                    case 2:
                        createSmeltingStage(group);
                        break;
                    case 3:
                        createProductsStage(group);
                        break;
                    default:
                        console.warn(`Unknown stage index: ${stageIndex}`);
                }
            } catch (error) {
                console.error(`Stage content creation error for stage ${stageIndex}:`, error);
            }
        }
        
        function createMiningStage(group) {
            try {
                // Drilling rig with proper materials
                const rigGeometry = new THREE.CylinderGeometry(1.5, 2, 3, 12);
                const rigMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const rig = new THREE.Mesh(rigGeometry, rigMaterial);
                rig.position.set(-5, 1.5, -3);
                rig.castShadow = true;
                group.add(rig);
                
                // Drilling mast
                const mastGeometry = new THREE.BoxGeometry(0.5, 8, 0.5);
                const mast = new THREE.Mesh(mastGeometry, rigMaterial);
                mast.position.set(-5, 5, -3);
                mast.castShadow = true;
                group.add(mast);
                miningEquipment.push(mast);
                
                // Excavator body
                const excavatorGeometry = new THREE.BoxGeometry(3, 2, 5);
                const excavatorMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
                const excavator = new THREE.Mesh(excavatorGeometry, excavatorMaterial);
                excavator.position.set(3, 1, 0);
                excavator.castShadow = true;
                group.add(excavator);
                
                // Excavator arm
                const armGeometry = new THREE.BoxGeometry(0.8, 0.8, 6);
                const arm = new THREE.Mesh(armGeometry, excavatorMaterial);
                arm.position.set(6, 2.5, 0);
                arm.rotation.z = -Math.PI / 6;
                arm.castShadow = true;
                group.add(arm);
                miningEquipment.push(arm);
                
                // Conveyor belt system
                const conveyorGeometry = new THREE.BoxGeometry(15, 0.3, 2);
                const conveyorMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const conveyor = new THREE.Mesh(conveyorGeometry, conveyorMaterial);
                conveyor.position.set(0, 0.5, 5);
                conveyor.castShadow = true;
                group.add(conveyor);
                
                // Mining trucks
                for (let i = 0; i < 2; i++) {
                    const truckGeometry = new THREE.BoxGeometry(2.5, 1.5, 4);
                    const truckMaterial = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
                    const truck = new THREE.Mesh(truckGeometry, truckMaterial);
                    truck.position.set(i * 5 - 2.5, 0.75, -6);
                    truck.rotation.y = i * 0.3;
                    truck.castShadow = true;
                    group.add(truck);
                    miningEquipment.push(truck);
                }
                
                // Ore stockpiles with varied colors
                const oreColors = [0x8B4513, 0x654321, 0xA0522D, 0x8B7355, 0x696969];
                for (let i = 0; i < 5; i++) {
                    const oreGeometry = new THREE.ConeGeometry(1, 1.5, 8);
                    const oreMaterial = new THREE.MeshLambertMaterial({ 
                        color: oreColors[Math.floor(Math.random() * oreColors.length)]
                    });
                    const ore = new THREE.Mesh(oreGeometry, oreMaterial);
                    ore.position.set(
                        (Math.random() - 0.5) * 10,
                        0.75,
                        (Math.random() - 0.5) * 8
                    );
                    ore.castShadow = true;
                    group.add(ore);
                }
            } catch (error) {
                console.error('Mining stage creation error:', error);
            }
        }
        
        function createTradingStage(group) {
            try {
                // Main data center building
                const buildingGeometry = new THREE.BoxGeometry(8, 10, 5);
                const buildingMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xf8f9fa,
                    metalness: 0.1,
                    roughness: 0.2
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.y = 5;
                building.castShadow = true;
                building.receiveShadow = true;
                group.add(building);
                
                // Communication towers
                for (let i = 0; i < 3; i++) {
                    const towerGeometry = new THREE.CylinderGeometry(0.2, 0.3, 12, 8);
                    const towerMaterial = new THREE.MeshLambertMaterial({ color: 0x34495E });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.set(
                        (i - 1) * 4,
                        6,
                        (i % 2 === 0 ? -1 : 1) * 4
                    );
                    tower.castShadow = true;
                    group.add(tower);
                    
                    // Antenna with proper emissive setup
                    const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
                    const antennaMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x1E88E5,
                        emissive: new THREE.Color(0x1E88E5),
                        emissiveIntensity: 0.5,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.set(
                        (i - 1) * 4,
                        12.75,
                        (i % 2 === 0 ? -1 : 1) * 4
                    );
                    group.add(antenna);
                    tradingElements.push(antenna);
                }
                
                // Holographic trading displays
                for (let i = 0; i < 4; i++) {
                    const displayGeometry = new THREE.PlaneGeometry(2, 1.5);
                    const displayMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x1E88E5,
                        transparent: true,
                        opacity: 0.6,
                        emissive: new THREE.Color(0x3498DB),
                        emissiveIntensity: 0.4,
                        metalness: 0.1,
                        roughness: 0.8
                    });
                    
                    const display = new THREE.Mesh(displayGeometry, displayMaterial);
                    display.position.set(
                        Math.cos(i * Math.PI / 2) * 5,
                        3,
                        Math.sin(i * Math.PI / 2) * 5
                    );
                    display.lookAt(0, 3, 0);
                    group.add(display);
                    tradingElements.push(display);
                }
            } catch (error) {
                console.error('Trading stage creation error:', error);
            }
        }
        
        function createSmeltingStage(group) {
            try {
                // Main blast furnace
                const furnaceGeometry = new THREE.CylinderGeometry(2.5, 3, 12, 16);
                const furnaceMaterial = new THREE.MeshLambertMaterial({ color: 0x2C3E50 });
                const furnace = new THREE.Mesh(furnaceGeometry, furnaceMaterial);
                furnace.position.set(0, 6, -3);
                furnace.castShadow = true;
                group.add(furnace);
                
                // Furnace glow effect
                const glowGeometry = new THREE.CylinderGeometry(2.2, 2.2, 0.5, 16);
                const glowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF4500,
                    emissive: new THREE.Color(0xFF2200),
                    emissiveIntensity: 1.5,
                    metalness: 0.0,
                    roughness: 1.0
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(0, 0.5, -3);
                group.add(glow);
                smeltingElements.push(glow);
                
                // Molten copper droplets
                for (let i = 0; i < 10; i++) {
                    const dropGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.1);
                    const dropMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFF6B35,
                        emissive: new THREE.Color(0xFF4500),
                        emissiveIntensity: 1.2,
                        metalness: 0.0,
                        roughness: 1.0
                    });
                    
                    const drop = new THREE.Mesh(dropGeometry, dropMaterial);
                    drop.position.set(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 4 + 1,
                        -2.5 + Math.random()
                    );
                    group.add(drop);
                    smeltingElements.push(drop);
                }
                
                // Electrolytic refining tanks
                for (let i = 0; i < 6; i++) {
                    const tankGeometry = new THREE.BoxGeometry(1.2, 2.5, 1);
                    const tankMaterial = new THREE.MeshLambertMaterial({ color: 0x4682B4 });
                    const tank = new THREE.Mesh(tankGeometry, tankMaterial);
                    tank.position.set(
                        (i - 2.5) * 1.8,
                        1.25,
                        4
                    );
                    tank.castShadow = true;
                    group.add(tank);
                    
                    // Electrolyte solution with glow
                    const solutionGeometry = new THREE.BoxGeometry(1, 0.3, 0.8);
                    const solutionMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00CED1,
                        transparent: true,
                        opacity: 0.8,
                        emissive: new THREE.Color(0x008B8B),
                        emissiveIntensity: 0.6,
                        metalness: 0.0,
                        roughness: 0.8
                    });
                    
                    const solution = new THREE.Mesh(solutionGeometry, solutionMaterial);
                    solution.position.set(
                        (i - 2.5) * 1.8,
                        2.35,
                        4
                    );
                    group.add(solution);
                    smeltingElements.push(solution);
                }
                
                // High-purity copper cathodes
                for (let i = 0; i < 20; i++) {
                    const cathodeGeometry = new THREE.BoxGeometry(1, 0.03, 1.5);
                    const cathodeMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xB87333,
                        metalness: 0.95,
                        roughness: 0.05
                    });
                    const cathode = new THREE.Mesh(cathodeGeometry, cathodeMaterial);
                    cathode.position.set(
                        (i % 5 - 2) * 1.3,
                        0.3 + Math.floor(i / 5) * 0.04,
                        6 + (Math.floor(i / 5) % 2) * 1
                    );
                    cathode.castShadow = true;
                    group.add(cathode);
                }
            } catch (error) {
                console.error('Smelting stage creation error:', error);
            }
        }
        
        function createProductsStage(group) {
            try {
                // Manufacturing facility
                const facilityGeometry = new THREE.BoxGeometry(12, 5, 8);
                const facilityMaterial = new THREE.MeshLambertMaterial({ color: 0xE5E5E5 });
                const facility = new THREE.Mesh(facilityGeometry, facilityMaterial);
                facility.position.set(0, 2.5, -4);
                facility.castShadow = true;
                facility.receiveShadow = true;
                group.add(facility);
                
                // Copper pipes with varied sizes
                for (let i = 0; i < 15; i++) {
                    const pipeRadius = 0.2 + Math.random() * 0.2;
                    const pipeGeometry = new THREE.CylinderGeometry(pipeRadius, pipeRadius, 2.5, 16);
                    const pipeMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xB87333,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const pipe = new THREE.Mesh(pipeGeometry, pipeMaterial);
                    pipe.position.set(
                        (Math.random() - 0.5) * 8,
                        1.25,
                        (Math.random() - 0.5) * 6 + 2
                    );
                    pipe.rotation.z = Math.PI / 2;
                    pipe.castShadow = true;
                    group.add(pipe);
                    finalProducts.push(pipe);
                }
                
                // Copper wire coils
                for (let i = 0; i < 8; i++) {
                    const coilGeometry = new THREE.TorusGeometry(0.8, 0.2, 8, 16);
                    const coilMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xCD853F,
                        metalness: 0.95,
                        roughness: 0.05
                    });
                    const coil = new THREE.Mesh(coilGeometry, coilMaterial);
                    coil.position.set(
                        (i % 4 - 1.5) * 2,
                        0.8 + Math.floor(i / 4) * 0.8,
                        4
                    );
                    coil.castShadow = true;
                    group.add(coil);
                    finalProducts.push(coil);
                }
                
                // Assembly conveyor belt
                const beltGeometry = new THREE.BoxGeometry(20, 0.2, 1);
                const beltMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const belt = new THREE.Mesh(beltGeometry, beltMaterial);
                belt.position.set(0, 0.1, 0);
                belt.castShadow = true;
                group.add(belt);
                
                // Robotic assembly arms
                for (let i = 0; i < 2; i++) {
                    const armBaseGeometry = new THREE.CylinderGeometry(0.4, 0.5, 2, 12);
                    const armBaseMaterial = new THREE.MeshLambertMaterial({ color: 0x2C3E50 });
                    const armBase = new THREE.Mesh(armBaseGeometry, armBaseMaterial);
                    armBase.position.set(
                        (i - 0.5) * 4,
                        1,
                        -1.5
                    );
                    armBase.castShadow = true;
                    group.add(armBase);
                    
                    const armSegmentGeometry = new THREE.BoxGeometry(0.3, 0.3, 2.5);
                    const armSegment = new THREE.Mesh(armSegmentGeometry, armBaseMaterial);
                    armSegment.position.set(
                        (i - 0.5) * 4,
                        2.5,
                        -0.5
                    );
                    armSegment.castShadow = true;
                    group.add(armSegment);
                    finalProducts.push(armSegment);
                }
            } catch (error) {
                console.error('Products stage creation error:', error);
            }
        }
        
        function createConveyor(group, spacing) {
            try {
                // Main conveyor belt
                const conveyorGeometry = new THREE.BoxGeometry(spacing * 0.8, 0.2, 1.5);
                const conveyorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.8
                });
                const conveyor = new THREE.Mesh(conveyorGeometry, conveyorMaterial);
                conveyor.position.set(spacing * 0.5, 0.1, 0);
                conveyor.receiveShadow = true;
                group.add(conveyor);
                
                // Animated flow indicators
                for (let i = 0; i < 4; i++) {
                    const indicatorGeometry = new THREE.BoxGeometry(0.2, 0.05, 1.3);
                    const indicatorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFD700,
                        emissive: new THREE.Color(0xFFD700),
                        emissiveIntensity: 0.3,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    
                    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                    indicator.position.set(
                        spacing * 0.2 + i * spacing * 0.15,
                        0.3,
                        0
                    );
                    group.add(indicator);
                    animationObjects.push(indicator);
                }
            } catch (error) {
                console.error('Conveyor creation error:', error);
            }
        }
        
        function goToStage(stageIndex) {
            if (isTransitioning || !isWebGLSupported || stageIndex < 0 || stageIndex >= stageData.length) {
                return;
            }
            
            try {
                showTransitionIndicator();
                isTransitioning = true;
                currentStage = stageIndex;
                
                // Update navigation UI
                const buttons = document.querySelectorAll('.nav-button');
                buttons.forEach((btn, i) => {
                    btn.classList.toggle('active', i === stageIndex);
                    btn.setAttribute('aria-pressed', i === stageIndex ? 'true' : 'false');
                });
                
                // Update stage information display
                const stageInfo = stageData[stageIndex];
                if (stageInfo) {
                    const titleEl = document.getElementById('stage-title');
                    const descEl = document.getElementById('stage-description');
                    const detailsEl = document.getElementById('process-details');
                    
                    if (titleEl) titleEl.textContent = stageInfo.title;
                    if (descEl) descEl.textContent = stageInfo.description;
                    if (detailsEl) detailsEl.textContent = stageInfo.process;
                    
                    // Update metrics display
                    const metrics = document.querySelectorAll('.metric');
                    if (metrics.length >= 3 && stageInfo.metrics) {
                        metrics.forEach((metric, i) => {
                            if (stageInfo.metrics[i]) {
                                const valueEl = metric.querySelector('.metric-value');
                                const labelEl = metric.querySelector('.metric-label');
                                
                                if (valueEl) valueEl.textContent = stageInfo.metrics[i].value;
                                if (labelEl) labelEl.textContent = stageInfo.metrics[i].label;
                            }
                        });
                    }
                }
                
                // Calculate camera target position
                const stageSpacing = isMobile() ? 35 : 45;
                const targetX = (stageIndex - 1.5) * stageSpacing;
                const targetY = isMobile() ? 10 : 15;
                const targetZ = isMobile() ? 25 : 35;
                animateCamera(targetX, targetY, targetZ);
                
            } catch (error) {
                console.error('Error in goToStage:', error);
                isTransitioning = false;
                hideTransitionIndicator();
            }
        }
        
        function animateCamera(targetX, targetY, targetZ) {
            const duration = 2000;
            const startTime = performance.now();
            const startPos = { 
                x: camera.position.x, 
                y: camera.position.y, 
                z: camera.position.z 
            };
            
            function updateCamera(currentTime) {
                try {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3); // Cubic ease-out
                    
                    if (camera && camera.position) {
                        camera.position.x = startPos.x + (targetX - startPos.x) * eased;
                        camera.position.y = startPos.y + (targetY - startPos.y) * eased;
                        camera.position.z = startPos.z + (targetZ - startPos.z) * eased;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(updateCamera);
                    } else {
                        isTransitioning = false;
                        hideTransitionIndicator();
                    }
                } catch (error) {
                    console.error('Camera animation error:', error);
                    isTransitioning = false;
                    hideTransitionIndicator();
                }
            }
            
            requestAnimationFrame(updateCamera);
        }
        
        function showTransitionIndicator() {
            const indicator = document.getElementById('transition-indicator');
            if (indicator) {
                indicator.classList.add('show');
            }
        }
        
        function hideTransitionIndicator() {
            const indicator = document.getElementById('transition-indicator');
            if (indicator) {
                indicator.classList.remove('show');
            }
        }
        
        function setupControls() {
            if (!renderer || !renderer.domElement) {
                console.warn('Renderer not available for control setup');
                return;
            }
            
            let targetRotationX = 0, targetRotationY = 0;
            let isDragging = false;
            let startX = 0, startY = 0;
            let lastTouchTime = 0;
            
            // Touch event handlers with proper passive flags
            const touchStartHandler = (event) => {
                if (event.touches.length === 1) {
                    isDragging = true;
                    startX = event.touches[0].clientX;
                    startY = event.touches[0].clientY;
                    lastTouchTime = performance.now();
                }
                event.preventDefault();
            };
            
            const touchEndHandler = () => {
                isDragging = false;
            };
            
            const touchMoveHandler = (event) => {
                if (!isDragging || event.touches.length !== 1) return;
                
                try {
                    const currentTime = performance.now();
                    if (currentTime - lastTouchTime < 16) return; // Throttle to ~60fps
                    lastTouchTime = currentTime;
                    
                    const deltaX = (event.touches[0].clientX - startX) / window.innerWidth;
                    const deltaY = (event.touches[0].clientY - startY) / window.innerHeight;
                    
                    targetRotationY += deltaX * 0.5;
                    targetRotationX += deltaY * 0.5;
                    
                    // Clamp rotation values
                    targetRotationX = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, targetRotationX));
                    targetRotationY = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, targetRotationY));
                    
                    startX = event.touches[0].clientX;
                    startY = event.touches[0].clientY;
                } catch (error) {
                    console.error('Touch move error:', error);
                }
                
                event.preventDefault();
            };
            
            // Mouse event handlers
            const mouseDownHandler = (event) => {
                isDragging = true;
                startX = event.clientX;
                startY = event.clientY;
            };
            
            const mouseUpHandler = () => {
                isDragging = false;
            };
            
            const mouseMoveHandler = (event) => {
                if (!isDragging) return;
                
                try {
                    const deltaX = (event.clientX - startX) / window.innerWidth;
                    const deltaY = (event.clientY - startY) / window.innerHeight;
                    
                    targetRotationY += deltaX * 0.3;
                    targetRotationX += deltaY * 0.3;
                    
                    // Clamp rotation values
                    targetRotationX = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, targetRotationX));
                    targetRotationY = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, targetRotationY));
                    
                    startX = event.clientX;
                    startY = event.clientY;
                } catch (error) {
                    console.error('Mouse move error:', error);
                }
            };
            
            // Add event listeners with proper options
            renderer.domElement.addEventListener('touchstart', touchStartHandler, { passive: false });
            renderer.domElement.addEventListener('touchend', touchEndHandler, { passive: true });
            renderer.domElement.addEventListener('touchmove', touchMoveHandler, { passive: false });
            
            renderer.domElement.addEventListener('mousedown', mouseDownHandler);
            renderer.domElement.addEventListener('mouseup', mouseUpHandler);
            renderer.domElement.addEventListener('mousemove', mouseMoveHandler);
            
            // Camera rotation update loop
            function updateCameraRotation() {
                try {
                    if (camera && camera.rotation) {
                        camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.05;
                        camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.05;
                    }
                    requestAnimationFrame(updateCameraRotation);
                } catch (error) {
                    console.error('Camera rotation error:', error);
                    // Continue the loop even on error
                    requestAnimationFrame(updateCameraRotation);
                }
            }
            
            updateCameraRotation();
        }
        
        function animate() {
            if (!isWebGLSupported) return;
            
            try {
                animationId = requestAnimationFrame(animate);
                
                const time = performance.now() * 0.001; // Use performance.now for better precision
                
                // Animate mining equipment with null checks
                miningEquipment.forEach((equipment, index) => {
                    if (!equipment) return;
                    
                    if (equipment.rotation) {
                        equipment.rotation.y += 0.01;
                    }
                    if (equipment.position) {
                        equipment.position.y += Math.sin(time + index) * 0.05;
                    }
                });
                
                // Animate trading elements
                tradingElements.forEach((element, index) => {
                    if (!element || !element.material) return;
                    
                    if (typeof element.material.emissiveIntensity !== 'undefined') {
                        element.material.emissiveIntensity = 0.5 + Math.sin(time * 2 + index) * 0.3;
                    }
                    if (element.rotation) {
                        element.rotation.y += 0.01;
                    }
                    if (element.position && element.geometry && element.geometry.type === 'PlaneGeometry') {
                        element.position.y += Math.sin(time * 2 + index) * 0.3;
                    }
                });
                
                // Animate smelting elements
                smeltingElements.forEach((element, index) => {
                    if (!element || !element.material) return;
                    
                    if (typeof element.material.emissiveIntensity !== 'undefined') {
                        element.material.emissiveIntensity = 1.0 + Math.sin(time * 3 + index) * 0.5;
                    }
                    if (element.position) {
                        element.position.y += Math.sin(time * 2 + index) * 0.08;
                    }
                });
                
                // Animate final products
                finalProducts.forEach((product, index) => {
                    if (!product) return;
                    
                    if (product.rotation) {
                        product.rotation.z += 0.005;
                        product.rotation.y += 0.003;
                    }
                    if (product.material && typeof product.material.metalness !== 'undefined') {
                        product.material.metalness = 0.8 + Math.sin(time + index) * 0.1;
                    }
                    if (product.position) {
                        product.position.y += Math.sin(time * 1.5 + index) * 0.02;
                    }
                });
                
                // Animate conveyor indicators
                animationObjects.forEach((obj, index) => {
                    if (obj && obj.position) {
                        obj.position.y = 0.3 + Math.sin(time * 3 + index) * 0.1;
                    }
                });
                
                // Slowly rotate stage platforms
                stages.forEach((stage) => {
                    if (stage && stage.rotation) {
                        stage.rotation.y += 0.002;
                    }
                });
                
                // Render the scene
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
                
            } catch (error) {
                console.error('Animation error:', error);
                // Continue animation loop even on error
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // Optimized resize handler with debouncing
        function handleResize() {
            if (!camera || !renderer) return;
            
            try {
                const newWidth = window.innerWidth;
                const newHeight = window.innerHeight;
                
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
                
                // Update FOV for mobile
                camera.fov = isMobile() ? 80 : 70;
                camera.updateProjectionMatrix();
                
            } catch (error) {
                console.error('Resize error:', error);
            }
        }
        
        window.addEventListener('resize', () => {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            resizeTimeout = setTimeout(handleResize, 100);
        });
        
        // Comprehensive cleanup function
        function cleanup() {
            try {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                
                if (renderer) {
                    renderer.dispose();
                    renderer.forceContextLoss();
                    renderer = null;
                }
                
                // Clean up scene objects
                if (scene) {
                    scene.traverse((object) => {
                        if (object.geometry) {
                            object.geometry.dispose();
                        }
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(material => {
                                    if (material.dispose) material.dispose();
                                });
                            } else if (object.material.dispose) {
                                object.material.dispose();
                            }
                        }
                    });
                    scene = null;
                }
                
                // Clear arrays
                stages.length = 0;
                animationObjects.length = 0;
                miningEquipment.length = 0;
                tradingElements.length = 0;
                smeltingElements.length = 0;
                finalProducts.length = 0;
                
            } catch (error) {
                console.error('Cleanup error:', error);
            }
        }
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Pause animations when page is hidden
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            } else {
                // Resume animations when page becomes visible
                if (isWebGLSupported) {
                    animate();
                }
            }
        });
        
        // Handle page unload
        window.addEventListener('beforeunload', cleanup);
        window.addEventListener('pagehide', cleanup);
        
        // Initialize when DOM is ready
        function initWhenReady() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        }
        
        // Start initialization
        initWhenReady();
        
    </script>
</body>
</html>
