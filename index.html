<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Mineral - Copper Supply Chain Journey</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: 
                radial-gradient(circle at 30% 70%, rgba(184, 115, 51, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, rgba(74, 144, 226, 0.15) 0%, transparent 50%),
                linear-gradient(135deg, #f8f9fa 0%, #e9ecef 25%, #dee2e6 50%, #ced4da 75%, #e9ecef 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(184, 115, 51, 0.02) 3px, rgba(184, 115, 51, 0.02) 6px),
                repeating-linear-gradient(-45deg, transparent, transparent 3px, rgba(74, 144, 226, 0.02) 3px, rgba(74, 144, 226, 0.02) 6px);
            pointer-events: none;
            z-index: 1;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #header {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 25px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(184, 115, 51, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        #logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 4px;
        }
        
        #logo-symbol {
            font-size: 18px;
            margin-right: 8px;
            background: linear-gradient(45deg, #b87333, #cd853f);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        #logo-text {
            font-size: 16px;
            font-weight: 700;
            background: linear-gradient(45deg, #4A90E2, #357abd);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }
        
        #tagline {
            font-size: 9px;
            color: #666;
            font-weight: 500;
        }
        
        #navigation {
            position: absolute;
            top: 80px;
            left: 15px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(184, 115, 51, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            max-width: 180px;
        }
        
        .nav-title {
            color: #b87333;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(184, 115, 51, 0.2);
            padding-bottom: 6px;
        }
        
        .nav-button {
            display: block;
            width: 100%;
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.1), rgba(74, 144, 226, 0.05));
            border: 1px solid rgba(74, 144, 226, 0.2);
            color: #333;
            padding: 8px 12px;
            margin: 6px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
            text-align: left;
            font-weight: 500;
        }
        
        .nav-button:hover {
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.2), rgba(74, 144, 226, 0.1));
            transform: translateX(3px);
            box-shadow: 0 2px 10px rgba(74, 144, 226, 0.2);
        }
        
        .nav-button.active {
            background: linear-gradient(135deg, rgba(184, 115, 51, 0.2), rgba(184, 115, 51, 0.1));
            border-color: rgba(184, 115, 51, 0.4);
            color: #b87333;
            font-weight: 600;
        }
        
        #stage-info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            max-width: 280px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(184, 115, 51, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        #stage-title {
            color: #b87333;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #stage-description {
            line-height: 1.4;
            font-size: 11px;
            color: #555;
            margin-bottom: 10px;
        }
        
        .process-details {
            font-size: 10px;
            color: #666;
            font-style: italic;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(184, 115, 51, 0.2);
        }
        
        .metrics {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(184, 115, 51, 0.2);
        }
        
        .metric {
            text-align: center;
            flex: 1;
        }
        
        .metric-value {
            font-size: 12px;
            font-weight: bold;
            color: #4A90E2;
        }
        
        .metric-label {
            font-size: 8px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-top: 2px;
        }
        
        #controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(184, 115, 51, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .control-text {
            font-size: 9px;
            margin-bottom: 2px;
            color: #666;
            font-weight: 500;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 16px;
            z-index: 1000;
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .loading-spinner {
            width: 30px;
            height: 30px;
            border: 3px solid rgba(184, 115, 51, 0.3);
            border-top: 3px solid #b87333;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 15px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .transition-indicator {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 90;
            background: rgba(184, 115, 51, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .transition-indicator.show {
            opacity: 1;
        }
    
@media screen and (max-width: 768px) {
    #header {
        width: 90%;
        left: 5%;
        transform: none;
        padding: 10px;
    }

    #navigation {
        top: auto;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        max-width: 90%;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 6px;
    }

    .nav-button {
        font-size: 10px;
        padding: 6px 8px;
        text-align: center;
        flex: 1 1 45%;
    }

    #stage-info {
        bottom: 90px;
        right: 50%;
        transform: translateX(50%);
        width: 90%;
        max-width: none;
        font-size: 12px;
    }

    #controls {
        top: auto;
        bottom: 160px;
        right: 50%;
        transform: translateX(50%);
        width: 90%;
        text-align: center;
    }

    #loading {
        width: 90%;
        font-size: 14px;
    }

    .control-text {
        font-size: 10px;
    }

    .metric-label,
    .metric-value {
        font-size: 10px;
    }

    .nav-title {
        font-size: 10px;
        text-align: center;
        width: 100%;
    }

    #transition-indicator {
        font-size: 10px;
        padding: 6px 12px;
        bottom: 100px;
    }
}

</style>
</head>
<body>
    <div id="loading">
        <div class="loading-spinner"></div>
        <div>Loading Copper Supply Chain Experience...</div>
    </div>
    
    <div id="container">
        <div id="header">
            <div id="logo-container">
                <div id="logo-symbol">‚¨¢</div>
                <div id="logo-text">OPEN MINERAL</div>
            </div>
            <div id="tagline">Copper Supply Chain ‚Ä¢ From Mine to Architecture</div>
        </div>
        
        <div id="navigation">
            <div class="nav-title">Supply Chain Journey</div>
            <button class="nav-button active" onclick="goToStage(0)">‚õèÔ∏è Ore Extraction</button>
            <button class="nav-button" onclick="goToStage(1)">üî∂ Open Mineral</button>
            <button class="nav-button" onclick="goToStage(2)">üî• Refined Metal</button>
            <button class="nav-button" onclick="goToStage(3)">‚ú® Final Product</button>
        </div>
        
        <div id="controls">
            <div class="control-text">üñ±Ô∏è Drag: Explore</div>
            <div class="control-text">üîç Scroll: Zoom</div>
            <div class="control-text">‚èØÔ∏è Auto-Play: ON</div>
        </div>
        
        <div id="stage-info">
            <h3 id="stage-title">Mining Operations</h3>
            <p id="stage-description">Large-scale open-pit mining operations extract copper ore using heavy machinery and advanced excavation techniques.</p>
            <div class="process-details" id="process-details">
                Excavators and haul trucks work continuously to extract copper-rich ore from geological deposits.
            </div>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value">5-10%</div>
                    <div class="metric-label">Cu Content</div>
                </div>
                <div class="metric">
                    <div class="metric-value">24/7</div>
                    <div class="metric-label">Operations</div>
                </div>
                <div class="metric">
                    <div class="metric-value">1000+</div>
                    <div class="metric-label">Tons/Day</div>
                </div>
            </div>
        </div>
        
        <div id="transition-indicator" class="transition-indicator">
            Transitioning to next stage...
        </div>
    </div>

    <script>
        let scene, camera, renderer, currentStage = 0;
        let stages = [];
        let isTransitioning = false;
        let animationObjects = [];
        let miningMachinery = [];
        let openMineralLogo = [];
        let smeltingEffects = [];
        let buildingElements = [];
        
        const stageData = [
            {
                title: "Mining Operations",
                description: "Large-scale open-pit mining operations extract copper ore using heavy machinery and advanced excavation techniques.",
                process: "Excavators and haul trucks work continuously to extract copper-rich ore from geological deposits.",
                metrics: [
                    { value: "5-10%", label: "Cu Content" },
                    { value: "24/7", label: "Operations" },
                    { value: "1000+", label: "Tons/Day" }
                ]
            },
            {
                title: "Open Mineral Platform",
                description: "Open Mineral's AI-powered digital platform connects miners directly with smelters, eliminating intermediaries through transparent pricing and blockchain technology.",
                process: "Real-time commodity mix analysis and automated trading algorithms optimize pricing for both buyers and sellers.",
                metrics: [
                    { value: "14+", label: "Countries" },
                    { value: "$2B+", label: "Volume" },
                    { value: "AI", label: "Powered" }
                ]
            },
            {
                title: "Refined Metal Processing",
                description: "Advanced smelting facilities transform copper concentrates through high-temperature processing, chemical purification, and electrolytic refining to produce 99.99% pure copper.",
                process: "Concentrates undergo flotation, smelting at 1200¬∞C, converting, and electrolytic refining to achieve commercial-grade purity.",
                metrics: [
                    { value: "99.99%", label: "Purity" },
                    { value: "1200¬∞C", label: "Process Temp" },
                    { value: "Electrolytic", label: "Refining" }
                ]
            },
            {
                title: "Final Copper Products",
                description: "Pure copper is transformed into high-quality architectural products including sheets, pipes, and facade panels that develop beautiful patina over time.",
                process: "Refined copper is rolled, formed, and fabricated into architectural elements prized for durability and aesthetic appeal.",
                metrics: [
                    { value: "100+", label: "Years Life" },
                    { value: "Premium", label: "Grade" },
                    { value: "Iconic", label: "Buildings" }
                ]
            }
        ];
        
        function init() {
            // Scene setup with light professional theme
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xf8f9fa, 80, 300);
            
            // Add professional background
            createProfessionalBackground();
            
            // Camera setup - positioned to see all stages
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 50);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf8f9fa, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Professional lighting
            setupProfessionalLighting();
            
            // Create educational stages
            createEducationalStages();
            
            // Start with first stage
            goToStage(0);
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            
            // Start animation
            animate();
            
            // Setup controls
            setupInteractiveControls();
        }
        
        function createProfessionalBackground() {
            // Clean professional grid
            const gridGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const gridMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xe9ecef,
                transparent: true,
                opacity: 0.2,
                wireframe: true
            });
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            grid.position.y = -10;
            scene.add(grid);
            
            // Subtle background elements
            for (let i = 0; i < 8; i++) {
                const hexGeometry = new THREE.RingGeometry(10, 12, 6);
                const hexMaterial = new THREE.MeshBasicMaterial({ 
                    color: i % 2 === 0 ? 0xb87333 : 0x4A90E2,
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.DoubleSide
                });
                const hex = new THREE.Mesh(hexGeometry, hexMaterial);
                hex.position.set(
                    (Math.random() - 0.5) * 150,
                    (Math.random() - 0.5) * 50,
                    -50 - Math.random() * 50
                );
                hex.rotation.z = Math.random() * Math.PI;
                scene.add(hex);
            }
        }
        
        function setupProfessionalLighting() {
            // Bright professional lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Increased ambient light
            scene.add(ambientLight);
            
            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.0); // Increased intensity
            mainLight.position.set(15, 25, 15); // Higher position
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.left = -100; // Wider shadow area
            mainLight.shadow.camera.right = 100;
            mainLight.shadow.camera.top = 100;
            mainLight.shadow.camera.bottom = -100;
            mainLight.shadow.camera.far = 100;
            scene.add(mainLight);
            
            // Additional lights for better coverage
            const leftLight = new THREE.DirectionalLight(0xffffff, 0.6);
            leftLight.position.set(-20, 20, 10);
            scene.add(leftLight);
            
            const rightLight = new THREE.DirectionalLight(0xffffff, 0.6);
            rightLight.position.set(20, 20, 10);
            scene.add(rightLight);
            
            // Accent lighting
            const accentLight = new THREE.PointLight(0xb87333, 0.4, 80); // Increased range
            accentLight.position.set(-10, 15, 5);
            scene.add(accentLight);
            
            // Fill light
            const fillLight = new THREE.DirectionalLight(0x4A90E2, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
        }
        
        function createEducationalStages() {
            const stageSpacing = 35; // Increased spacing between stages
            
            for (let i = 0; i < 4; i++) {
                const stageGroup = new THREE.Group();
                const xPos = (i - 1.5) * stageSpacing;
                stageGroup.position.set(xPos, 0, 0);
                
                // Create stage platform
                createStagePlatform(stageGroup, i);
                
                // Add stage title
                createStageTitle(stageGroup, i);
                
                // Create detailed stage content
                createDetailedStageContent(stageGroup, i);
                
                // Add connecting elements
                if (i < 3) {
                    createConnectionPath(stageGroup, stageSpacing, i);
                }
                
                stages.push(stageGroup);
                scene.add(stageGroup);
            }
        }
        
        function createStagePlatform(group, stageIndex) {
            // Clean platform design
            const platformGeometry = new THREE.CylinderGeometry(12, 12, 1.5, 16);
            const platformMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -0.75;
            platform.receiveShadow = true;
            platform.castShadow = true;
            group.add(platform);
            
            // Platform accent
            const accentGeometry = new THREE.TorusGeometry(12, 0.3, 8, 32);
            const accentColor = stageIndex === 1 ? 0x4A90E2 : 0xb87333;
            const accentMaterial = new THREE.MeshPhongMaterial({ color: accentColor });
            const accent = new THREE.Mesh(accentGeometry, accentMaterial);
            accent.position.y = 0;
            accent.rotation.x = Math.PI / 2;
            group.add(accent);
        }
        
        function createDetailedStageContent(group, stageIndex) {
            switch(stageIndex) {
                case 0:
                    createMiningScene(group);
                    break;
                case 1:
                    createOpenMineralScene(group);
                    break;
                case 2:
                    createSmeltingScene(group);
                    break;
                case 3:
                    createArchitecturalScene(group);
                    break;
            }
        }
        
        function createMiningScene(group) {
            // Large excavator
            const excavatorBody = new THREE.BoxGeometry(4, 2, 6);
            const excavatorMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const excavator = new THREE.Mesh(excavatorBody, excavatorMaterial);
            excavator.position.set(-5, 1, 0);
            excavator.castShadow = true;
            group.add(excavator);
            miningMachinery.push(excavator);
            
            // Excavator arm
            const armGeometry = new THREE.BoxGeometry(0.8, 0.8, 8);
            const arm = new THREE.Mesh(armGeometry, excavatorMaterial);
            arm.position.set(-1, 3, 0);
            arm.rotation.z = -Math.PI / 6;
            arm.castShadow = true;
            group.add(arm);
            miningMachinery.push(arm);
            
            // Haul trucks
            for (let i = 0; i < 3; i++) {
                const truckGeometry = new THREE.BoxGeometry(3, 2, 5);
                const truckMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
                const truck = new THREE.Mesh(truckGeometry, truckMaterial);
                truck.position.set(
                    i * 6 - 6,
                    1,
                    -8 + i * 2
                );
                truck.rotation.y = i * 0.3;
                truck.castShadow = true;
                group.add(truck);
                miningMachinery.push(truck);
            }
            
            // Realistic copper ore deposits with varied minerals
            const oreColors = [0x8B4513, 0x654321, 0x4A4A4A, 0x556B2F, 0xA0522D, 0x6B8E23];
            const oreNames = ['Chalcopyrite', 'Bornite', 'Malachite', 'Azurite', 'Cuprite', 'Chrysocolla'];
            
            for (let i = 0; i < 25; i++) {
                const oreGeometry = new THREE.DodecahedronGeometry(Math.random() * 1.2 + 0.4);
                const colorIndex = Math.floor(Math.random() * oreColors.length);
                const oreMaterial = new THREE.MeshLambertMaterial({ 
                    color: oreColors[colorIndex],
                    roughness: 0.8 + Math.random() * 0.2,
                    metalness: Math.random() * 0.3
                });
                const ore = new THREE.Mesh(oreGeometry, oreMaterial);
                ore.position.set(
                    (Math.random() - 0.5) * 28,
                    Math.random() * 1.5,
                    (Math.random() - 0.5) * 28
                );
                ore.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                ore.castShadow = true;
                group.add(ore);
            }
            
            // Raw rock formations
            for (let i = 0; i < 15; i++) {
                const rockGeometry = new THREE.SphereGeometry(Math.random() * 2 + 1, 8, 6);
                const rockMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x696969,
                    roughness: 1.0
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 30,
                    Math.random() * 0.8,
                    (Math.random() - 0.5) * 30
                );
                rock.scale.set(1, 0.6, 1); // Flatten slightly
                rock.castShadow = true;
                group.add(rock);
            }
            
            // Ore concentrate piles
            for (let i = 0; i < 6; i++) {
                const pileGeometry = new THREE.ConeGeometry(2 + Math.random(), 1.5 + Math.random(), 8);
                const pileMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9
                });
                const pile = new THREE.Mesh(pileGeometry, pileMaterial);
                pile.position.set(
                    (Math.random() - 0.5) * 20,
                    0.75,
                    (Math.random() - 0.5) * 20
                );
                pile.castShadow = true;
                group.add(pile);
            }
            
            // Mining pit structure
            const pitGeometry = new THREE.CylinderGeometry(12, 8, 4, 16, 1, true);
            const pitMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                side: THREE.DoubleSide
            });
            const pit = new THREE.Mesh(pitGeometry, pitMaterial);
            pit.position.y = -2;
            group.add(pit);
        }
        
        function createOpenMineralScene(group) {
            // Central building with Open Mineral branding
            const buildingGeometry = new THREE.BoxGeometry(8, 12, 6);
            const buildingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf8f9fa,
                metalness: 0.1,
                roughness: 0.2
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = 6;
            building.castShadow = true;
            building.receiveShadow = true;
            group.add(building);
            
            // Create the Open Mineral logo on the building facade
            // Main geometric mountain shape - triangular elements
            const logoGroup = new THREE.Group();
            
            // Left mountain peak (darkest blue)
            const peak1Geometry = new THREE.ConeGeometry(1.2, 3, 3);
            const peak1Material = new THREE.MeshPhongMaterial({ 
                color: 0x1565C0,
                metalness: 0.3,
                roughness: 0.7
            });
            const peak1 = new THREE.Mesh(peak1Geometry, peak1Material);
            peak1.position.set(-1.5, 1, 0);
            peak1.rotation.y = Math.PI / 6;
            logoGroup.add(peak1);
            
            // Center mountain peak (medium blue)
            const peak2Geometry = new THREE.ConeGeometry(1.5, 4, 3);
            const peak2Material = new THREE.MeshPhongMaterial({ 
                color: 0x1976D2,
                metalness: 0.3,
                roughness: 0.7
            });
            const peak2 = new THREE.Mesh(peak2Geometry, peak2Material);
            peak2.position.set(0, 1.5, 0);
            peak2.rotation.y = -Math.PI / 6;
            logoGroup.add(peak2);
            
            // Right mountain peak (lighter blue)
            const peak3Geometry = new THREE.ConeGeometry(1, 2.5, 3);
            const peak3Material = new THREE.MeshPhongMaterial({ 
                color: 0x2196F3,
                metalness: 0.3,
                roughness: 0.7
            });
            const peak3 = new THREE.Mesh(peak3Geometry, peak3Material);
            peak3.position.set(1.2, 0.8, 0);
            peak3.rotation.y = Math.PI / 3;
            logoGroup.add(peak3);
            
            // Geometric wireframe elements (representing data/tech)
            const wireGeometry = new THREE.OctahedronGeometry(0.8);
            const wireMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x42A5F5,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const wireframe = new THREE.Mesh(wireGeometry, wireMaterial);
            wireframe.position.set(2.5, 1, 0);
            logoGroup.add(wireframe);
            
            // Position logo on building facade
            logoGroup.position.set(0, 8, 3.1);
            logoGroup.scale.set(1.2, 1.2, 1.2);
            building.add(logoGroup);
            openMineralLogo.push(logoGroup);
            
            // Company name text simulation with geometric blocks
            const letterSpacing = 0.8;
            const textY = 4;
            const letters = ['O', 'P', 'E', 'N', ' ', 'M', 'I', 'N', 'E', 'R', 'A', 'L'];
            
            for (let i = 0; i < letters.length; i++) {
                if (letters[i] !== ' ') {
                    const letterGeometry = new THREE.BoxGeometry(0.5, 1, 0.2);
                    const letterMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x1976D2,
                        emissive: 0x0D47A1,
                        emissiveIntensity: 0.2
                    });
                    const letter = new THREE.Mesh(letterGeometry, letterMaterial);
                    letter.position.set(
                        (i - letters.length/2) * letterSpacing,
                        textY,
                        3.1
                    );
                    building.add(letter);
                }
            }
            
            // Digital trading nodes orbiting the building
            for (let i = 0; i < 12; i++) {
                const nodeGeometry = new THREE.SphereGeometry(0.6);
                const nodeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x00BCD4,
                    emissive: 0x006064,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0.8
                });
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                const angle = (i / 12) * Math.PI * 2;
                const radius = 12 + Math.sin(i) * 2;
                node.position.set(
                    Math.cos(angle) * radius,
                    4 + Math.sin(Date.now() * 0.001 + i) * 3,
                    Math.sin(angle) * radius
                );
                group.add(node);
                openMineralLogo.push(node);
            }
            
            // Data connection network
            for (let i = 0; i < 8; i++) {
                const lineGeometry = new THREE.BoxGeometry(0.3, 0.3, 15);
                const lineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x1E88E5,
                    emissive: 0x0D47A1,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.6
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(
                    Math.cos(i) * 8,
                    6,
                    Math.sin(i) * 8
                );
                line.rotation.y = i * Math.PI / 4;
                group.add(line);
                openMineralLogo.push(line);
            }
            
            // Holographic trading interface
            const interfaceGeometry = new THREE.PlaneGeometry(10, 6);
            const interfaceMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x1976D2,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const interface = new THREE.Mesh(interfaceGeometry, interfaceMaterial);
            interface.position.set(0, 8, 0);
            interface.rotation.x = -Math.PI / 6;
            group.add(interface);
            
            // Floating data particles
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.2);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x42A5F5,
                    emissive: 0x1976D2,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 25,
                    Math.random() * 15 + 2,
                    (Math.random() - 0.5) * 25
                );
                group.add(particle);
                openMineralLogo.push(particle);
            }
        }
        
        function createSmeltingScene(group) {
            // No building - focus entirely on the refining process
            
            // Multiple large smelting furnaces
            for (let i = 0; i < 3; i++) {
                const furnaceGeometry = new THREE.CylinderGeometry(3, 4, 12, 16);
                const furnaceMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const furnace = new THREE.Mesh(furnaceGeometry, furnaceMaterial);
                furnace.position.set(
                    (i - 1) * 8,
                    6,
                    -5
                );
                furnace.castShadow = true;
                group.add(furnace);
                
                // Furnace chimneys with glowing tops
                const chimneyGeometry = new THREE.CylinderGeometry(0.8, 1.2, 6, 8);
                const chimneyMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
                chimney.position.set(
                    (i - 1) * 8,
                    15,
                    -5
                );
                chimney.castShadow = true;
                group.add(chimney);
                
                // Glowing furnace openings
                const glowGeometry = new THREE.CylinderGeometry(2.5, 2.5, 0.5, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF4500,
                    emissive: 0xFF2200,
                    emissiveIntensity: 1.0
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(
                    (i - 1) * 8,
                    3,
                    -5
                );
                group.add(glow);
            }
            
            // Large concentrate hoppers feeding the furnaces
            for (let i = 0; i < 4; i++) {
                const hopperGeometry = new THREE.ConeGeometry(2.5, 5, 8);
                const hopperMaterial = new THREE.MeshLambertMaterial({ color: 0x708090 });
                const hopper = new THREE.Mesh(hopperGeometry, hopperMaterial);
                hopper.position.set(
                    (i - 1.5) * 6,
                    8,
                    5
                );
                hopper.castShadow = true;
                group.add(hopper);
                
                // Concentrate material in hoppers
                const concentrateGeometry = new THREE.ConeGeometry(2, 2, 8);
                const concentrateMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const concentrate = new THREE.Mesh(concentrateGeometry, concentrateMaterial);
                concentrate.position.set(
                    (i - 1.5) * 6,
                    6.5,
                    5
                );
                group.add(concentrate);
            }
            
            // Massive pouring ladles
            for (let i = 0; i < 2; i++) {
                const ladleGeometry = new THREE.CylinderGeometry(2, 1.5, 4, 12);
                const ladleMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
                const ladle = new THREE.Mesh(ladleGeometry, ladleMaterial);
                ladle.position.set(
                    (i - 0.5) * 12,
                    8,
                    0
                );
                ladle.rotation.z = Math.PI / 8;
                ladle.castShadow = true;
                group.add(ladle);
            }
            
            // Spectacular molten copper flowing effects
            for (let i = 0; i < 40; i++) {
                const moltenGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.4);
                const moltenMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF4500,
                    emissive: 0xFF2200,
                    emissiveIntensity: 1.2
                });
                const molten = new THREE.Mesh(moltenGeometry, moltenMaterial);
                molten.position.set(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 15
                );
                group.add(molten);
                smeltingEffects.push(molten);
            }
            
            // Electrolytic refining tanks in a line
            for (let i = 0; i < 8; i++) {
                const tankGeometry = new THREE.BoxGeometry(2.5, 3, 2);
                const tankMaterial = new THREE.MeshLambertMaterial({ color: 0x4682B4 });
                const tank = new THREE.Mesh(tankGeometry, tankMaterial);
                tank.position.set(
                    (i - 3.5) * 3,
                    1.5,
                    10
                );
                tank.castShadow = true;
                group.add(tank);
                
                // Electrolytic solution glow
                const solutionGeometry = new THREE.BoxGeometry(2.2, 0.5, 1.8);
                const solutionMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00CED1,
                    emissive: 0x008B8B,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.8
                });
                const solution = new THREE.Mesh(solutionGeometry, solutionMaterial);
                solution.position.set(
                    (i - 3.5) * 3,
                    2.8,
                    10
                );
                group.add(solution);
            }
            
            // High-purity copper cathodes (99.99%) in precise stacks
            for (let i = 0; i < 24; i++) {
                const cathodeGeometry = new THREE.BoxGeometry(1.8, 0.05, 2.8);
                const cathodeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xb87333,
                    metalness: 0.98,
                    roughness: 0.02,
                    reflectivity: 0.95
                });
                const cathode = new THREE.Mesh(cathodeGeometry, cathodeMaterial);
                cathode.position.set(
                    (i % 6 - 2.5) * 2.2,
                    0.5 + Math.floor(i / 12) * 0.06,
                    12 + (Math.floor(i / 6) % 2) * 2.5
                );
                cathode.castShadow = true;
                group.add(cathode);
            }
            
            // Conveyor system for finished products
            const conveyorGeometry = new THREE.BoxGeometry(25, 0.4, 2);
            const conveyorMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const conveyor = new THREE.Mesh(conveyorGeometry, conveyorMaterial);
            conveyor.position.set(0, 0.2, -10);
            conveyor.castShadow = true;
            group.add(conveyor);
            
            // Rolling mill for sheet production
            for (let i = 0; i < 4; i++) {
                const rollerGeometry = new THREE.CylinderGeometry(1, 1, 8, 16);
                const rollerMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
                const roller = new THREE.Mesh(rollerGeometry, rollerMaterial);
                roller.position.set(
                    12,
                    2 + (i % 2) * 2.5,
                    -2 + Math.floor(i / 2) * 4
                );
                roller.rotation.z = Math.PI / 2;
                roller.castShadow = true;
                group.add(roller);
            }
            
            // Quality control station with precision instruments
            const qcStationGeometry = new THREE.BoxGeometry(5, 4, 4);
            const qcStationMaterial = new THREE.MeshLambertMaterial({ color: 0xF0F0F0 });
            const qcStation = new THREE.Mesh(qcStationGeometry, qcStationMaterial);
            qcStation.position.set(-12, 2, 8);
            qcStation.castShadow = true;
            group.add(qcStation);
            
            // Final copper products ready for shipping
            const productTypes = [
                { geo: new THREE.BoxGeometry(3, 0.08, 2), color: 0xcd853f }, // Sheets
                { geo: new THREE.CylinderGeometry(0.3, 0.3, 4), color: 0xb87333 }, // Rods
                { geo: new THREE.BoxGeometry(2, 1.2, 4), color: 0xb87333 } // Ingots
            ];
            
            for (let i = 0; i < 15; i++) {
                const productType = productTypes[Math.floor(Math.random() * productTypes.length)];
                const product = new THREE.Mesh(productType.geo, 
                    new THREE.MeshPhongMaterial({ 
                        color: productType.color,
                        metalness: 0.9,
                        roughness: 0.1
                    }));
                product.position.set(
                    (Math.random() - 0.5) * 20,
                    0.8,
                    -8 + Math.random() * 4
                );
                product.rotation.y = Math.random() * Math.PI;
                product.castShadow = true;
                group.add(product);
            }
        }
        
        function createArchitecturalScene(group) {
            // Main building showcase - modern copper facade
            const mainBuildingGeometry = new THREE.BoxGeometry(16, 14, 3);
            const mainBuildingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xb87333,  // Rich copper color
                metalness: 0.9,
                roughness: 0.1,
                reflectivity: 0.8,
                envMapIntensity: 1.0
            });
            const mainBuilding = new THREE.Mesh(mainBuildingGeometry, mainBuildingMaterial);
            mainBuilding.position.set(0, 7, -8);
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            group.add(mainBuilding);
            buildingElements.push(mainBuilding);
            
            // Copper facade panels with different finishes
            const panelRows = 4;
            const panelCols = 6;
            for (let i = 0; i < panelRows; i++) {
                for (let j = 0; j < panelCols; j++) {
                    const panelGeometry = new THREE.BoxGeometry(2.4, 3, 0.2);
                    const panelMaterial = new THREE.MeshPhongMaterial({ 
                        color: i % 2 === 0 ? 0xcd853f : 0xb87333,  // Alternating copper tones
                        metalness: 0.95,
                        roughness: 0.05 + (i * 0.02), // Varying roughness
                        reflectivity: 0.9
                    });
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    panel.position.set(
                        (j - panelCols/2 + 0.5) * 2.6,
                        (i - panelRows/2 + 0.5) * 3.2 + 7,
                        -6.4
                    );
                    panel.castShadow = true;
                    panel.receiveShadow = true;
                    group.add(panel);
                    buildingElements.push(panel);
                }
            }
            
            // Premium copper roofing system
            const roofGeometry = new THREE.BoxGeometry(18, 0.5, 6);
            const roofMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A8B3B,  // Green patina on aged copper
                metalness: 0.7,
                roughness: 0.3,
                normalScale: new THREE.Vector2(0.5, 0.5)
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 14.5, -8);
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);
            buildingElements.push(roof);
            
            // Copper architectural details - cornices
            for (let i = 0; i < 3; i++) {
                const corniceGeometry = new THREE.BoxGeometry(17, 0.4, 0.8);
                const corniceMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x9A6324,  // Weathered copper
                    metalness: 0.8,
                    roughness: 0.2
                });
                const cornice = new THREE.Mesh(corniceGeometry, corniceMaterial);
                cornice.position.set(0, 13 - i * 5, -6.2);
                cornice.castShadow = true;
                group.add(cornice);
                buildingElements.push(cornice);
            }
            
            // Decorative copper elements - geometric patterns
            for (let i = 0; i < 12; i++) {
                const decorGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 6);
                const decorMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xcd853f,
                    metalness: 0.95,
                    roughness: 0.05
                });
                const decor = new THREE.Mesh(decorGeometry, decorMaterial);
                decor.position.set(
                    (i % 6 - 2.5) * 2.5,
                    12,
                    -6
                );
                decor.rotation.x = Math.PI / 2;
                decor.castShadow = true;
                group.add(decor);
                buildingElements.push(decor);
            }
            
            // High-end copper window frames
            for (let i = 0; i < 12; i++) {
                const frameGeometry = new THREE.TorusGeometry(1.2, 0.15, 8, 16);
                const frameMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xb87333,
                    metalness: 0.95,
                    roughness: 0.05
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.set(
                    (i % 4 - 1.5) * 3.5,
                    4 + Math.floor(i / 4) * 3,
                    -6.3
                );
                frame.castShadow = true;
                group.add(frame);
                buildingElements.push(frame);
                
                // Glass windows
                const glassGeometry = new THREE.CircleGeometry(1.1, 16);
                const glassMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.3,
                    reflectivity: 0.8
                });
                const glass = new THREE.Mesh(glassGeometry, glassMaterial);
                glass.position.set(
                    (i % 4 - 1.5) * 3.5,
                    4 + Math.floor(i / 4) * 3,
                    -6.4
                );
                group.add(glass);
            }
            
            // Copper guttering system
            const gutterGeometry = new THREE.BoxGeometry(16, 0.3, 0.4);
            const gutterMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B7355,
                metalness: 0.9,
                roughness: 0.1
            });
            const gutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            gutter.position.set(0, 1, -5.8);
            gutter.castShadow = true;
            group.add(gutter);
            
            // Copper downspouts
            for (let i = 0; i < 4; i++) {
                const downspoutGeometry = new THREE.CylinderGeometry(0.15, 0.15, 7);
                const downspoutMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8B7355,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const downspout = new THREE.Mesh(downspoutGeometry, downspoutMaterial);
                downspout.position.set(
                    (i - 1.5) * 5,
                    4.5,
                    -5.5
                );
                downspout.castShadow = true;
                group.add(downspout);
            }
            
            // Premium copper entrance canopy
            const canopyGeometry = new THREE.BoxGeometry(6, 0.2, 3);
            const canopyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x9A6324,
                metalness: 0.8,
                roughness: 0.2
            });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.set(0, 3, -5);
            canopy.castShadow = true;
            group.add(canopy);
            buildingElements.push(canopy);
            
            // Surrounding copper landscape elements
            for (let i = 0; i < 6; i++) {
                const sculptureGeometry = new THREE.ConeGeometry(0.8, 2.5, 3);
                const sculptureMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xb87333,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const sculpture = new THREE.Mesh(sculptureGeometry, sculptureMaterial);
                sculpture.position.set(
                    (Math.random() - 0.5) * 25,
                    1.25,
                    Math.random() * 10 + 5
                );
                sculpture.rotation.y = Math.random() * Math.PI;
                sculpture.castShadow = true;
                group.add(sculpture);
                buildingElements.push(sculpture);
            }
        }
        
        function createConnectionPath(group, spacing, stageIndex) {
            const pathGeometry = new THREE.BoxGeometry(spacing * 0.8, 0.3, 3);
            const pathMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xe9ecef,
                transparent: true,
                opacity: 0.7
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.position.set(spacing * 0.5, 0, 0);
            path.receiveShadow = true;
            group.add(path);
            
            // Flow indicators
            for (let i = 0; i < 4; i++) {
                const indicatorGeometry = new THREE.ConeGeometry(0.3, 1, 4);
                const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                    color: stageIndex === 0 ? 0xb87333 : 0x4A90E2
                });
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                indicator.position.set(
                    spacing * 0.2 + i * spacing * 0.15,
                    1,
                    0
                );
                indicator.rotation.z = -Math.PI / 2;
                group.add(indicator);
                animationObjects.push(indicator);
            }
        }
        
        function viewAllStages() {
            if (isTransitioning) return;
            
            showTransitionIndicator();
            isTransitioning = true;
            currentStage = -1;
            
            // Clear active buttons
            document.querySelectorAll('.nav-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Update stage info
            document.getElementById('stage-title').textContent = "Complete Supply Chain";
            document.getElementById('stage-description').textContent = "Overview of the entire copper supply chain from mining operations through Open Mineral's platform to final architectural products.";
            document.getElementById('process-details').textContent = "Four integrated stages showcase the journey from raw ore extraction to premium copper building facades.";
            
            // Update metrics
            const metrics = document.querySelectorAll('.metric');
            if (metrics.length >= 3) {
                metrics[0].querySelector('.metric-value').textContent = "4";
                metrics[0].querySelector('.metric-label').textContent = "Stages";
                metrics[1].querySelector('.metric-value').textContent = "Global";
                metrics[1].querySelector('.metric-label').textContent = "Scale";
                metrics[2].querySelector('.metric-value').textContent = "Cu";
                metrics[2].querySelector('.metric-label').textContent = "Focus";
            }
            
            // Position camera to see all stages
            animateCamera(0, 25, 50);
        }
        
        function createStageTitle(group, stageIndex) {
            const stageTitles = [
                "COPPER MINING OPERATIONS",
                "OPEN MINERAL PLATFORM", 
                "SMELTING & REFINING FACILITY",
                "ARCHITECTURAL COPPER PRODUCTS"
            ];
            
            const stageSubtitles = [
                "Open-Pit Mining & Ore Processing",
                "Digital Trading & AI Analytics",
                "99.99% Pure Copper Production", 
                "Premium Building Facades"
            ];
            
            // Create title text using geometric shapes to represent letters
            const titleY = 18;
            const title = stageTitles[stageIndex];
            const subtitle = stageSubtitles[stageIndex];
            
            // Main title with geometric blocks
            for (let i = 0; i < title.length; i++) {
                if (title[i] !== ' ') {
                    const letterGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.2);
                    const letterMaterial = new THREE.MeshPhongMaterial({ 
                        color: stageIndex === 1 ? 0x1976D2 : 0xb87333,
                        emissive: stageIndex === 1 ? 0x0D47A1 : 0x8B4513,
                        emissiveIntensity: 0.2
                    });
                    const letter = new THREE.Mesh(letterGeometry, letterMaterial);
                    letter.position.set(
                        (i - title.length/2) * 1.0,
                        titleY,
                        0
                    );
                    letter.castShadow = true;
                    group.add(letter);
                }
            }
            
            // Subtitle with smaller blocks
            for (let i = 0; i < subtitle.length; i++) {
                if (subtitle[i] !== ' ') {
                    const subtitleGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.1);
                    const subtitleMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x666666,
                        opacity: 0.8,
                        transparent: true
                    });
                    const subtitleLetter = new THREE.Mesh(subtitleGeometry, subtitleMaterial);
                    subtitleLetter.position.set(
                        (i - subtitle.length/2) * 0.5,
                        titleY - 2.5,
                        0
                    );
                    subtitleLetter.castShadow = true;
                    group.add(subtitleLetter);
                }
            }
        }
        
        function goToStage(stageIndex) {
            if (isTransitioning) return;
            
            showTransitionIndicator();
            isTransitioning = true;
            currentStage = stageIndex;
            
            // Update UI
            document.querySelectorAll('.nav-button').forEach((btn, i) => {
                btn.classList.toggle('active', i === stageIndex);
            });
            
            // Update stage info
            const stageInfo = stageData[stageIndex];
            document.getElementById('stage-title').textContent = stageInfo.title;
            document.getElementById('stage-description').textContent = stageInfo.description;
            document.getElementById('process-details').textContent = stageInfo.process;
            
            // Update metrics
            const metrics = document.querySelectorAll('.metric');
            if (metrics.length >= 3 && stageInfo.metrics) {
                metrics.forEach((metric, i) => {
                    if (stageInfo.metrics[i]) {
                        metric.querySelector('.metric-value').textContent = stageInfo.metrics[i].value;
                        metric.querySelector('.metric-label').textContent = stageInfo.metrics[i].label;
                    }
                });
            }
            
            // Animate camera to stage
            const targetX = (stageIndex - 1.5) * 35; // Updated for new spacing
            animateCamera(targetX, 15, 40);
        }
        
        function animateCamera(targetX, targetY, targetZ) {
            const duration = 2000;
            const startTime = Date.now();
            const startPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                
                camera.position.x = startPos.x + (targetX - startPos.x) * eased;
                camera.position.y = startPos.y + (targetY - startPos.y) * eased;
                camera.position.z = startPos.z + (targetZ - startPos.z) * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                } else {
                    isTransitioning = false;
                    hideTransitionIndicator();
                }
            }
            
            updateCamera();
        }
        
        function showTransitionIndicator() {
            const indicator = document.getElementById('transition-indicator');
            indicator.classList.add('show');
        }
        
        function hideTransitionIndicator() {
            const indicator = document.getElementById('transition-indicator');
            indicator.classList.remove('show');
        }
        
        function setupInteractiveControls() {
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let isDragging = false;
            
            document.addEventListener('mousedown', () => { isDragging = true; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            
            document.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                mouseX = (event.clientX - window.innerWidth / 2) / window.innerWidth;
                mouseY = (event.clientY - window.innerHeight / 2) / window.innerHeight;
                
                targetRotationX = mouseY * 0.2;
                targetRotationY = mouseX * 0.2;
            });
            
            document.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * 0.03;
                camera.position.z = Math.max(25, Math.min(100, camera.position.z));
            });
            
            function updateCameraRotation() {
                camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.05;
                camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.05;
                requestAnimationFrame(updateCameraRotation);
            }
            
            updateCameraRotation();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            try {
                const time = Date.now() * 0.001;
                
                // Animate mining machinery
                if (miningMachinery.length > 0) {
                    miningMachinery.forEach((machine, index) => {
                        if (machine && machine.rotation) {
                            machine.rotation.y += 0.005;
                            machine.position.y += Math.sin(time + index) * 0.02;
                        }
                    });
                }
                
                // Animate Open Mineral elements
                if (openMineralLogo.length > 0) {
                    openMineralLogo.forEach((element, index) => {
                        if (element && element.geometry) {
                            if (element.geometry.type === 'SphereGeometry') {
                                const angle = (index / 8) * Math.PI * 2;
                                element.position.x = Math.cos(angle + time * 0.5) * 10;
                                element.position.z = Math.sin(angle + time * 0.5) * 10;
                                element.position.y = 4 + Math.sin(time * 2 + index) * 2;
                            }
                            if (element.rotation) {
                                element.rotation.y += 0.01;
                            }
                        }
                    });
                }
                
                // Animate smelting effects
                if (smeltingEffects.length > 0) {
                    smeltingEffects.forEach((molten, index) => {
                        if (molten && molten.position && molten.material) {
                            molten.position.y += Math.sin(time * 3 + index) * 0.1;
                            molten.material.emissiveIntensity = 0.8 + Math.sin(time * 4 + index) * 0.4;
                        }
                    });
                }
                
                // Animate building elements with subtle movement
                if (buildingElements.length > 0) {
                    buildingElements.forEach((element, index) => {
                        if (element && element.material) {
                            element.material.metalness = 0.7 + Math.sin(time + index) * 0.1;
                        }
                    });
                }
                
                // Animate flow indicators
                if (animationObjects.length > 0) {
                    animationObjects.forEach((obj, index) => {
                        if (obj && obj.position && obj.rotation) {
                            obj.position.y = 1 + Math.sin(time * 2 + index) * 0.2;
                            obj.rotation.z = -Math.PI / 2 + Math.sin(time + index) * 0.1;
                        }
                    });
                }
                
                // Rotate stages slightly
                if (stages.length > 0) {
                    stages.forEach((stage, index) => {
                        if (stage && stage.rotation) {
                            stage.rotation.y += 0.002;
                        }
                    });
                }
                
                renderer.render(scene, camera);
            } catch (error) {
                console.log("Animation error:", error);
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize the scene
        init();
    </script>
</body>
</html>
